<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Property Search</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    /* [ your existing CSS — unchanged for brevity ] */
  </style>
</head>

<body>
<div class="wrap">
  <div class="bleed"><div id="map"></div></div>

  <div class="searchBar" id="searchForm">
    <div class="field">
      <label for="q">Location</label>
      <input id="q" placeholder="Town, postcode" />
    </div>
    <div class="field">
      <label for="tenure">Tenure</label>
      <select id="tenure">
        <option value="any">Any</option>
        <option value="to let">To Let</option>
        <option value="for sale">For Sale</option>
      </select>
    </div>
    <div class="field">
      <label for="type">Type</label>
      <select id="type"><option value="any">Any</option></select>
    </div>
    <div class="field">
      <label for="radius">Radius</label>
      <select id="radius">
        <option value="any">Any</option>
        <option value="1">1 mile</option>
        <option value="3">3 miles</option>
        <option value="5">5 miles</option>
        <option value="10">10 miles</option>
        <option value="15">15 miles</option>
        <option value="25">25 miles</option>
        <option value="50">50 miles</option>
      </select>
    </div>
    <div class="field">
      <label for="minSize">Min size</label>
      <input id="minSize" type="number" inputmode="numeric" />
    </div>
    <div class="field">
      <label for="maxSize">Max size</label>
      <input id="maxSize" type="number" inputmode="numeric" />
    </div>
    <button class="btn" id="searchBtn" type="button">Search</button>
  </div>

  <div class="meta" id="statusText">Loading properties…</div>
  <div class="meta" id="resultsCount"></div>
  <div class="cards" id="results"></div>
</div>

<script>
let allProperties = [];
let map, markers, searchMarker;
const MAPBOX_TOKEN = ""; // optional

function getPrimaryImage(p){ /* [unchanged logic here] */ }
async function geocodePlace(q){ /* [unchanged logic here] */ }
function haversine(lat1, lon1, lat2, lon2){ /* [unchanged logic here] */ }
function sortByDistance(list, point){ /* [unchanged logic here] */ }
function milesToMeters(mi){ return mi * 1609.344; }
function sizeText(p){ /* [unchanged logic here] */ }
function getTypesArray(p){ /* [unchanged logic here] */ }
function getTenureLabel(p){ /* [unchanged logic here] */ }

function initMap(){ /* [unchanged logic here] */ }
function updateMap(list, focusPoint){ /* [unchanged logic here] */ }

function render(list, context = {}){ /* [unchanged logic here] */ }

function parseQS(str){ const sp=new URLSearchParams(str.startsWith('?')?str.slice(1):str); const o={}; for(const [k,v] of sp.entries()) o[k]=v; return o; }
function getIncomingParams(){ /* [unchanged logic here] */ }

let _didURLHydrateFallback = false;

async function applyFilters(){
  let q = document.getElementById('q').value.trim();
  if (!q) {
    const incoming = getIncomingParams();
    if (incoming.q) q = incoming.q.trim();
  }

  if (!q && !_didURLHydrateFallback) {
    const qp = new URLSearchParams(location.search).get('q');
    if (qp) {
      document.getElementById('q').value = qp;
      _didURLHydrateFallback = true;
      return applyFilters();
    }
  }

  const tenure = document.getElementById('tenure').value;
  const typeEl = document.getElementById('type');
  let type = (typeEl?.value || 'any');
  if (type === 'any' && typeEl?.dataset?.prefill) type = typeEl.dataset.prefill;
  const radiusVal = document.getElementById('radius').value;

  const tenureLC = String(tenure).toLowerCase();
  const typeLC = String(type).toLowerCase();

  const base = allProperties.filter(p => {
    if (tenureLC !== 'any') {
      const legacy = String(p.tenure || p.transaction_type || '').toLowerCase();
      const isLet = (p.to_let === true) || /to\s*let|letting|lease/.test(legacy);
      const isSale = (p.for_sale === true) || /for\s*sale|sale|freehold/.test(legacy);
      if (tenureLC === 'to let' && !isLet) return false;
      if (tenureLC === 'for sale' && !isSale) return false;
    }
    if (typeLC !== 'any') {
      const types = getTypesArray(p);
      if (!types.lc.some(t => t.includes(typeLC))) return false;
    }
    return true;
  });

  // if no query, just render filtered list
  if (!q) {
    render(base);
    updateMap(base);
    return;
  }

  const point = await geocodePlace(q);
  if (!point) {
    render(base);
    updateMap(base);
    return;
  }

  let finalList = sortByDistance(base, point);

  let radiusMiles = null;
  if (radiusVal !== 'any') {
    radiusMiles = Number(radiusVal);
    const meterLimit = milesToMeters(radiusMiles);
    finalList = finalList.filter(p => isFinite(p.__distance) && p.__distance <= meterLimit);
  }

  if (finalList.length > 60) finalList = finalList.slice(0, 60);

  render(finalList, { nearLabel: point.label || q, radiusMiles });
  updateMap(finalList, point);
}

async function loadProperties(){
  try {
    const res = await fetch('./properties.json', { cache: 'no-store' });
    const raw = await res.json();
    allProperties = raw.map((p, i) => ({ id: p.id ?? p.slug ?? p.uid ?? i, ...p }));

    const typeSet = new Set();
    allProperties.forEach(p => {
      if (Array.isArray(p.types)) p.types.forEach(t => t && typeSet.add(String(t).trim()));
      if (p.type) typeSet.add(String(p.type).trim());
      if (p.property_type) typeSet.add(String(p.property_type).trim());
    });
    const typeSel = document.getElementById('type');
    typeSel.innerHTML =
      `<option value="any">Any</option>` +
      [...typeSet].filter(Boolean).sort((a,b)=>a.localeCompare(b)).map(t=>`<option>${t}</option>`).join('');
    if (typeSel.dataset.prefill) typeSel.value = typeSel.dataset.prefill;

    applyFilters();
  } catch (e) {
    document.getElementById('statusText').textContent = 'Failed to load properties.json';
    console.error(e);
  }
}

function prefillFromURL() {
  const incoming = getIncomingParams();
  const p = new URLSearchParams(location.search);
  const setVal = (id, v) => { if (v != null && v !== '') { const el = document.getElementById(id); if (el) el.value = v; } };

  setVal('q', incoming.q || p.get('q'));
  setVal('tenure', (incoming.tenure || p.get('tenure') || 'any').toLowerCase());
  setVal('radius', incoming.radius || p.get('radius') || 'any');
  setVal('minSize', incoming.minSize || p.get('minSize'));
  setVal('maxSize', incoming.maxSize || p.get('maxSize'));

  const typePref = incoming.type || p.get('type') || 'any';
  const typeEl = document.getElementById('type');
  if (typeEl) typeEl.dataset.prefill = typePref;
}

document.addEventListener('DOMContentLoaded', () => {
  initMap();
  document.getElementById('searchBtn').onclick = applyFilters;
  document.getElementById('q').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); applyFilters(); }
  });
  prefillFromURL();
  loadProperties();
});
</script>

<!-- Squarespace iframe resize -->
<script>
(function () {
  const MSG_TYPE = 'gjs-prop-height';
  const frameId = new URLSearchParams(location.search).get('frameId') || 'search';
  function calcHeight() {
    const wrap = document.querySelector('.wrap');
    if (!wrap) return document.documentElement.scrollHeight;
    const rect = wrap.getBoundingClientRect();
    return Math.max(Math.ceil(rect.top + window.scrollY + rect.height + 4), 300);
  }
  function sendHeight() {
    window.parent?.postMessage({ type: MSG_TYPE, id: frameId, height: calcHeight() }, '*');
  }
  window._gjsSendHeight = sendHeight;
  new ResizeObserver(sendHeight).observe(document.documentElement);
  new ResizeObserver(sendHeight).observe(document.body);
  new MutationObserver(sendHeight).observe(document.body, { childList: true, subtree: true, attributes: true, characterData: true });
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('img').forEach(img => {
      if (!img.complete) img.addEventListener('load', sendHeight, { once: true });
    });
  });
  setTimeout(sendHeight, 100);
})();
</script>
</body>
</html>
